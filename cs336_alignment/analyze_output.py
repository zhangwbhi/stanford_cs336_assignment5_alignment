import json
import sys
import argparse

# --- Configuration ---
# This is the file generated by run_math_baseline.py
DEFAULT_RESULTS_FILE = "math_baseline_results.jsonl"
DEFAULT_EXAMPLES_TO_EXTRACT = 10
# ---------------------

def analyze_results(results_path, num_to_extract, category_to_print):
    """
    Reads a .jsonl results file and extracts N examples for each
    of the three categories defined in Problem (math_baseline) (b).
    """
    categories = {
        "cat1_correct": [],         # (format_reward=1, answer_reward=1)
        "cat2_format_only": [],     # (format_reward=1, answer_reward=0)
        "cat3_incorrect_all": [],   # (format_reward=0, answer_reward=0)
    }

    print(f"Analyzing {results_path} to find {num_to_extract} examples per category...")

    try:
        with open(results_path, "r") as f:
            for line in f:
                # Check if all categories (or the specific one) are full
                all_full = all(len(v) >= num_to_extract for v in categories.values())
                if category_to_print == 1 and len(categories["cat1_correct"]) >= num_to_extract:
                    break
                if category_to_print == 2 and len(categories["cat2_format_only"]) >= num_to_extract:
                    break
                if category_to_print == 3 and len(categories["cat3_incorrect_all"]) >= num_to_extract:
                    break
                if all_full:
                    print("All categories are full. Stopping analysis.")
                    break

                try:
                    result = json.loads(line)
                    reward_data = result.get("reward_data", {})

                    # Use .get() for safety, defaulting to 0.0
                    format_reward = reward_data.get("format_reward", 0.0)
                    answer_reward = reward_data.get("answer_reward", 0.0)

                    # --- Categorize ---
                    # (1) correct with both format and answer reward 1
                    if format_reward == 1.0 and answer_reward == 1.0:
                        if len(categories["cat1_correct"]) < num_to_extract:
                            categories["cat1_correct"].append(result)

                    # (2) format reward 1 and answer reward 0
                    elif format_reward == 1.0 and answer_reward == 0.0:
                        if len(categories["cat2_format_only"]) < num_to_extract:
                            categories["cat2_format_only"].append(result)

                    # (3) format reward 0 and answer reward 0
                    elif format_reward == 0.0 and answer_reward == 0.0:
                        if len(categories["cat3_incorrect_all"]) < num_to_extract:
                            categories["cat3_incorrect_all"].append(result)

                except json.JSONDecodeError:
                    print(f"Skipping malformed line: {line[:50]}...", file=sys.stderr)

    except FileNotFoundError:
        print(f"Error: Results file not found at {results_path}", file=sys.stderr)
        return

    print_results(categories, category_to_print)


def print_results(categories, category_to_print):
    """Helper function to pretty-print the extracted examples."""

    print_all = (category_to_print is None)

    # --- Category 1 ---
    if print_all or category_to_print == 1:
        print("\n" + "="*80)
        print(f"--- CATEGORY 1: Correct Format & Answer (format=1, answer=1) ---")
        print(f"(Found {len(categories['cat1_correct'])} examples)\n")

        for i, ex in enumerate(categories['cat1_correct']):
            print(f"--- Example {i+1} ---")
            # The prompt is long, just show the last line (the actual question part)
            print(f"  Prompt:\n... {ex.get('prompt', 'N/A')}\n")
            print(f"  Generated Text:\n{ex.get('generated_text', 'N/A')}\n")
            print(f"  Ground Truth:\n{ex.get('ground_truth', 'N/A')}\n")
            print(f"  Reward Data:\n{json.dumps(ex.get('reward_data', {}), indent=4)}\n")

    # --- Category 2 ---
    if print_all or category_to_print == 2:
        print("\n" + "="*80)
        print(f"--- CATEGORY 2: Correct Format & Wrong Answer (format=1, answer=0) ---")
        print(f"(Found {len(categories['cat2_format_only'])} examples)\n")

        for i, ex in enumerate(categories['cat2_format_only']):
            print(f"--- Example {i+1} ---")
            print(f"  Prompt:\n... {ex.get('prompt', 'N/A')}\n")
            print(f"  Generated Text:\n{ex.get('generated_text', 'N/A')}\n")
            print(f"  Ground Truth:\n{ex.get('ground_truth', 'N/A')}\n")
            print(f"  Reward Data:\n{json.dumps(ex.get('reward_data', {}), indent=4)}\n")

    # --- Category 3 ---
    if print_all or category_to_print == 3:
        print("\n" + "="*80)
        print(f"--- CATEGORY 3: Wrong Format & Wrong Answer (format=0, answer=0) ---")
        print(f"(Found {len(categories['cat3_incorrect_all'])} examples)\n")

        for i, ex in enumerate(categories['cat3_incorrect_all']):
            print(f"--- Example {i+1} ---")
            print(f"  Prompt:\n... {ex.get('prompt', 'N/A')}\n")
            print(f"  Generated Text:\n{ex.get('generated_text', 'N/A')}\n")
            print(f"  Ground Truth:\n{ex.get('ground_truth', 'N/A')}\n")
            print(f"  Reward Data:\n{json.dumps(ex.get('reward_data', {}), indent=4)}\n")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Analyze MATH baseline results.")
    parser.add_argument(
        "-f", "--file",
        default=DEFAULT_RESULTS_FILE,
        help=f"Path to the results .jsonl file (default: {DEFAULT_RESULTS_FILE})"
    )
    parser.add_argument(
        "-n", "--num",
        type=int,
        default=DEFAULT_EXAMPLES_TO_EXTRACT,
        help=f"Number of examples to extract per category (default: {DEFAULT_EXAMPLES_TO_EXTRACT})"
    )
    parser.add_argument(
        "-c", "--category",
        type=int,
        choices=[1, 2, 3],
        default=None,  # Default to None, meaning "all"
        help="Specific category to print (1, 2, or 3). If not provided, all categories are printed."
    )
    args = parser.parse_args()

    analyze_results(args.file, args.num, args.category)

